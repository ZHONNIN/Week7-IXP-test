<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rewrite Me: An Editable Story</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            transition: background 300ms ease;
            min-height: 100vh;
        }

        /* Mood Themes */
        body.mood-warm {
            background: linear-gradient(135deg, #FFF3E0 0%, #FFD7B5 100%);
            color: #3a2a1a;
        }
        body.mood-warm .accent { color: #FF7A59; }

        body.mood-cold {
            background: linear-gradient(135deg, #E6F2FF 0%, #C9E3FF 100%);
            color: #1f2a3a;
        }
        body.mood-cold .accent { color: #3C78D8; }

        body.mood-bloom {
            background: linear-gradient(135deg, #E9FFE9 0%, #C8F7CF 100%);
            color: #203224;
        }
        body.mood-bloom .accent { color: #2CB67D; }

        body.mood-storm {
            background: linear-gradient(135deg, #FFF0F0 0%, #FFC9C9 100%);
            color: #3a1f1f;
        }
        body.mood-storm .accent { color: #E04949; }

        body.mood-void {
            background: linear-gradient(135deg, #F5F5F7 0%, #E7E7EC 100%);
            color: #2a2a2a;
        }
        body.mood-void .accent { color: #888; }

        body.mood-neutral {
            background: #FAFAFA;
            color: #222;
        }
        body.mood-neutral .accent { color: #666; }

        /* Panel System */
        .panel {
            display: none;
            min-height: 100vh;
            padding: 2rem;
        }

        .panel.active {
            display: flex;
            flex-direction: column;
        }

        /* Intro Panel */
        #intro-panel {
            align-items: center;
            justify-content: center;
        }

        .intro-content {
            text-align: center;
            max-width: 600px;
        }

        .intro-content h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            font-weight: 700;
            line-height: 1.2;
        }

        .intro-content p {
            font-size: 1.25rem;
            margin-bottom: 2.5rem;
            opacity: 0.8;
            line-height: 1.6;
        }

        /* Editor Panel */
        #editor-panel {
            align-items: center;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 920px;
            margin: 0 auto 2rem;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .top-bar h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .top-bar-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .editor-container {
            width: 100%;
            max-width: 920px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 3rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .instruction {
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 2rem;
            opacity: 0.7;
            font-style: italic;
        }

        #story {
            font-size: 1.5rem;
            line-height: 2.2;
            max-width: 720px;
            margin: 0 auto 2.5rem;
            padding: 2rem;
            min-height: 300px;
            border: 2px dashed transparent;
            border-radius: 8px;
            transition: all 200ms ease;
            outline: none;
        }

        #story:focus {
            border-color: currentColor;
            opacity: 1;
        }

        #story mark.new {
            background: rgba(255, 215, 0, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
            animation: glow 1.2s ease-out forwards;
        }

        @keyframes glow {
            0% { background: rgba(255, 215, 0, 0.5); }
            100% { background: transparent; }
        }

        .edit-log {
            max-width: 720px;
            margin: 0 auto 1.5rem;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 8px;
            min-height: 80px;
        }

        .edit-log h3 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.75rem;
            opacity: 0.6;
        }

        .edit-log-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .edit-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 20px;
            font-size: 0.875rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .edit-chip .badge {
            font-weight: 700;
            font-size: 0.75rem;
        }

        .edit-chip.added .badge { color: #2CB67D; }
        .edit-chip.removed .badge { color: #E04949; }

        .edit-chip .time {
            font-size: 0.75rem;
            opacity: 0.5;
            margin-left: 0.25rem;
        }

        .stats-line {
            max-width: 720px;
            margin: 0 auto;
            text-align: center;
            font-size: 0.95rem;
            opacity: 0.7;
        }

        /* Ending Panel */
        #ending-panel {
            align-items: center;
            justify-content: center;
        }

        .ending-content {
            max-width: 800px;
            width: 100%;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 3rem;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        }

        .ending-content h2 {
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .ending-summary {
            text-align: center;
            font-size: 1rem;
            opacity: 0.7;
            margin-bottom: 2rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 8px;
        }

        .ending-text {
            font-size: 1.5rem;
            line-height: 2;
            margin-bottom: 2.5rem;
            padding: 2rem;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            font-style: italic;
        }

        .config-card {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.02);
            border-radius: 8px;
        }

        .config-card h3 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 1rem;
            opacity: 0.6;
        }

        .mood-strip {
            height: 8px;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .matched-words {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .word-chip {
            padding: 0.375rem 0.75rem;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 20px;
            font-size: 0.875rem;
        }

        .ending-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Buttons */
        button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 200ms ease;
            background: rgba(0, 0, 0, 0.8);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(255, 255, 255, 0.9);
            color: inherit;
            border: 2px solid currentColor;
        }

        button.small {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        /* Badges and Chips */
        .mood-badge {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Toggle Switch */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .toggle-switch input[type="checkbox"] {
            width: 44px;
            height: 24px;
            appearance: none;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 200ms ease;
        }

        .toggle-switch input[type="checkbox"]:checked {
            background: rgba(0, 0, 0, 0.6);
        }

        .toggle-switch input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: transform 200ms ease;
        }

        .toggle-switch input[type="checkbox"]:checked::before {
            transform: translateX(20px);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 1rem 1.5rem;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            gap: 1rem;
            align-items: center;
            opacity: 0;
            transition: all 300ms ease;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .toast button {
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .intro-content h1 { font-size: 2.5rem; }
            #story { font-size: 1.25rem; line-height: 2; }
            .ending-text { font-size: 1.25rem; }
        }

        /* Hidden */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body class="mood-neutral">
    <!-- Intro Panel -->
    <div id="intro-panel" class="panel active">
        <div class="intro-content">
            <h1>Rewrite Me: An Editable Story</h1>
            <p>Every word you change shifts the meaning. Delete. Add. Reshape the narrative and discover where your edits lead.</p>
            <button onclick="app.startExperience()" aria-label="Start the experience">Begin</button>
        </div>
    </div>

    <!-- Editor Panel -->
    <div id="editor-panel" class="panel">
        <div class="top-bar">
            <h2>Rewrite Me</h2>
            <div class="top-bar-controls">
                <div class="mood-badge" id="mood-badge" aria-live="polite">Neutral</div>
                <label class="toggle-switch">
                    <span>Sound</span>
                    <input type="checkbox" id="sound-toggle" aria-label="Toggle sound effects">
                </label>
                <button class="small secondary" onclick="app.reset()" aria-label="Reset story">Reset</button>
                <button class="small" onclick="app.generateEnding()" aria-label="Generate ending">Generate Ending</button>
            </div>
        </div>

        <div class="editor-container">
            <p class="instruction">Delete or add words. Your edits change the mood.</p>

            <div id="story" contenteditable="true" aria-label="Editable story text" spellcheck="false">I still remember that morning.
You said it was only the wind moving the curtain,
but I think it was the moment everything changed.
We packed our words into careful boxes.
Maybe love is just a rearrangement of sentences,
or maybe it is what stays when everything else is rewritten.</div>

            <div class="edit-log">
                <h3>Recent Changes</h3>
                <div class="edit-log-items" id="edit-log-items" aria-live="polite">
                    <span style="opacity: 0.5; font-size: 0.875rem;">Your edits will appear here...</span>
                </div>
            </div>

            <div class="stats-line" id="stats-line" aria-live="polite">
                Added: 0 · Removed: 0 · Unique words: 0
            </div>
        </div>
    </div>

    <!-- Ending Panel -->
    <div id="ending-panel" class="panel">
        <div class="ending-content">
            <h2>Your Story's End</h2>

            <div class="ending-summary" id="ending-summary"></div>

            <div class="ending-text" id="ending-text"></div>

            <div class="config-card">
                <h3>Configuration</h3>
                <div class="mood-strip" id="mood-strip"></div>
                <div class="matched-words" id="matched-words"></div>
                <div id="ending-stats" style="font-size: 0.875rem; opacity: 0.7;"></div>
            </div>

            <div class="ending-actions">
                <button onclick="app.copyFinalText()" aria-label="Copy final story text">Copy Final Text</button>
                <button onclick="app.downloadJSON()" aria-label="Download session data as JSON">Download JSON</button>
                <button class="secondary" onclick="app.editAgain()" aria-label="Return to editor">Edit Again</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast" role="alert" aria-live="assertive"></div>

    <!-- Audio elements (optional) -->
    <audio id="audio-warm" src="warm.mp3" preload="none"></audio>
    <audio id="audio-cold" src="cold.mp3" preload="none"></audio>
    <audio id="audio-bloom" src="bloom.mp3" preload="none"></audio>
    <audio id="audio-storm" src="storm.mp3" preload="none"></audio>
    <audio id="audio-void" src="void.mp3" preload="none"></audio>
    <audio id="audio-neutral" src="neutral.mp3" preload="none"></audio>

    <script>
        const ORIGINAL_STORY = `I still remember that morning.
You said it was only the wind moving the curtain,
but I think it was the moment everything changed.
We packed our words into careful boxes.
Maybe love is just a rearrangement of sentences,
or maybe it is what stays when everything else is rewritten.`;

        const LEXICONS = {
            WARM: ["love","stay","home","tender","soft","blanket","warm","together"],
            COLD: ["fear","leave","gone","alone","silent","ice","cold","distant"],
            BLOOM: ["hope","begin","light","morning","seed","bloom","open","again"],
            STORM: ["anger","break","never","shout","storm","fire","burn","hurt"],
            VOID: ["forget","empty","quiet","hollow","nothing","erase","missing","lost"]
        };

        const MOOD_PRIORITY = ['WARM', 'BLOOM', 'COLD', 'STORM', 'VOID'];

        const MOOD_COLORS = {
            WARM: '#FF7A59',
            COLD: '#3C78D8',
            BLOOM: '#2CB67D',
            STORM: '#E04949',
            VOID: '#888888',
            NEUTRAL: '#666666'
        };

        const app = {
            previousTokens: [],
            totalAdded: 0,
            totalRemoved: 0,
            editLog: [],
            currentMood: 'NEUTRAL',
            soundEnabled: false,
            autoSaveInterval: null,
            matchedWordCounts: {},

            init() {
                this.previousTokens = this.tokenize(ORIGINAL_STORY);
                this.setupEventListeners();
                this.loadAutoSave();
                this.startAutoSave();
            },

            setupEventListeners() {
                const storyEl = document.getElementById('story');

                storyEl.addEventListener('input', () => {
                    this.handleEdit();
                });

                storyEl.addEventListener('paste', (e) => {
                    e.preventDefault();
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                    document.execCommand('insertText', false, text);
                });

                document.getElementById('sound-toggle').addEventListener('change', (e) => {
                    this.soundEnabled = e.target.checked;
                });
            },

            tokenize(text) {
                // Split on whitespace and punctuation, keep meaningful tokens
                return text.toLowerCase()
                    .split(/[\s\n\r]+/)
                    .map(token => token.replace(/[.,!?;:()"\[\]]/g, ''))
                    .filter(token => token.length > 0);
            },

            handleEdit() {
                const storyEl = document.getElementById('story');
                const currentText = storyEl.innerText || storyEl.textContent;
                const currentTokens = this.tokenize(currentText);

                // Find added and removed tokens
                const addedTokens = currentTokens.filter(token =>
                    !this.previousTokens.includes(token)
                );
                const removedTokens = this.previousTokens.filter(token =>
                    !currentTokens.includes(token)
                );

                // Update counters
                if (addedTokens.length > 0) {
                    this.totalAdded += addedTokens.length;
                    addedTokens.forEach(token => this.logEdit(token, 'added'));
                }

                if (removedTokens.length > 0) {
                    this.totalRemoved += removedTokens.length;
                    removedTokens.forEach(token => this.logEdit(token, 'removed'));
                }

                // Update previous tokens
                this.previousTokens = currentTokens;

                // Update mood
                this.updateMood();

                // Update stats
                this.updateStats();

                // Auto-generate ending if threshold reached
                if ((this.totalAdded + this.totalRemoved) >= 15) {
                    setTimeout(() => {
                        if (document.getElementById('editor-panel').classList.contains('active')) {
                            this.generateEnding();
                        }
                    }, 500);
                }
            },

            logEdit(word, type) {
                const timestamp = new Date().toLocaleTimeString('en-US', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });

                this.editLog.unshift({ word, type, timestamp });

                // Keep last 12
                if (this.editLog.length > 12) {
                    this.editLog = this.editLog.slice(0, 12);
                }

                this.renderEditLog();
            },

            renderEditLog() {
                const container = document.getElementById('edit-log-items');

                if (this.editLog.length === 0) {
                    container.innerHTML = '<span style="opacity: 0.5; font-size: 0.875rem;">Your edits will appear here...</span>';
                    return;
                }

                container.innerHTML = this.editLog.map(edit => `
                    <div class="edit-chip ${edit.type}">
                        <span class="badge">${edit.type === 'added' ? '+' : '−'}</span>
                        <span>${edit.word}</span>
                        <span class="time">${edit.timestamp}</span>
                    </div>
                `).join('');
            },

            updateMood() {
                const currentTokens = this.previousTokens;
                const moodCounts = {};
                this.matchedWordCounts = {};

                // Count tokens for each mood
                Object.keys(LEXICONS).forEach(mood => {
                    const count = currentTokens.filter(token =>
                        LEXICONS[mood].includes(token)
                    ).length;
                    moodCounts[mood] = count;

                    // Track which words matched
                    currentTokens.forEach(token => {
                        if (LEXICONS[mood].includes(token)) {
                            this.matchedWordCounts[token] = (this.matchedWordCounts[token] || 0) + 1;
                        }
                    });
                });

                // Find mood with highest count
                let newMood = 'NEUTRAL';
                let maxCount = 0;

                for (const mood of MOOD_PRIORITY) {
                    if (moodCounts[mood] > maxCount) {
                        maxCount = moodCounts[mood];
                        newMood = mood;
                    }
                }

                // Only update if mood changed
                if (newMood !== this.currentMood) {
                    const oldMood = this.currentMood;
                    this.currentMood = newMood;
                    this.applyMoodTheme();

                    // Play sound if enabled
                    if (this.soundEnabled && oldMood !== 'NEUTRAL') {
                        this.playMoodSound(newMood);
                    }
                }
            },

            applyMoodTheme() {
                const body = document.body;

                // Remove all mood classes
                body.className = body.className.replace(/mood-\w+/g, '');

                // Add current mood class
                body.classList.add(`mood-${this.currentMood.toLowerCase()}`);

                // Update mood badge
                const badge = document.getElementById('mood-badge');
                badge.textContent = this.currentMood.charAt(0) + this.currentMood.slice(1).toLowerCase();
            },

            playMoodSound(mood) {
                const audio = document.getElementById(`audio-${mood.toLowerCase()}`);
                if (audio) {
                    audio.currentTime = 0;
                    audio.volume = 0.3;
                    audio.play().catch(() => {
                        // Audio play failed (user hasn't interacted yet), ignore
                    });
                }
            },

            updateStats() {
                const uniqueWords = new Set(this.previousTokens).size;
                const statsLine = document.getElementById('stats-line');
                statsLine.textContent = `Added: ${this.totalAdded} · Removed: ${this.totalRemoved} · Unique words: ${uniqueWords}`;
            },

            reset() {
                const storyEl = document.getElementById('story');
                storyEl.textContent = ORIGINAL_STORY;

                this.previousTokens = this.tokenize(ORIGINAL_STORY);
                this.totalAdded = 0;
                this.totalRemoved = 0;
                this.editLog = [];
                this.currentMood = 'NEUTRAL';
                this.matchedWordCounts = {};

                this.applyMoodTheme();
                this.renderEditLog();
                this.updateStats();

                localStorage.removeItem('rewriteMe_autosave');

                this.showToast('Story reset to original');
            },

            generateEnding() {
                const currentText = document.getElementById('story').innerText;
                const currentTokens = this.tokenize(currentText);

                // Determine ending based on rules
                let ending = '';

                // Check each ending condition in order
                if (this.currentMood === 'WARM' &&
                    currentTokens.some(t => ["stay","together","home"].includes(t))) {
                    ending = `You kept the words that hold. The curtain still moves, but now it feels like breathing.
You chose to stay, and staying became a place.`;
                }
                else if (this.currentMood === 'BLOOM' &&
                         currentTokens.some(t => ["begin","again","light","morning"].includes(t))) {
                    ending = `You reopened the sentence. Morning fits in the margins.
Not a return, but a start that keeps starting.`;
                }
                else if (this.currentMood === 'COLD' &&
                         currentTokens.some(t => ["leave","gone","alone"].includes(t))) {
                    ending = `You trimmed the page to its winter.
What remains is clean, and the echo travels farther than you do.`;
                }
                else if (this.currentMood === 'STORM' &&
                         currentTokens.some(t => ["break","burn","never","anger"].includes(t))) {
                    ending = `You let the fire edit for you. The lines glow, then go dark.
Even smoke is a kind of handwriting.`;
                }
                else if (this.currentMood === 'VOID' &&
                         currentTokens.some(t => ["forget","empty","erase","nothing"].includes(t))) {
                    ending = `You erased gently until the paper remembered silence.
The story is lighter now, almost air.`;
                }
                else {
                    ending = `You moved a few commas and the day kept going.
Some endings are just the page deciding to rest.`;
                }

                // Populate ending panel
                document.getElementById('ending-summary').textContent =
                    `Edits: +${this.totalAdded} / −${this.totalRemoved}. Mood detected: ${this.currentMood}.`;

                document.getElementById('ending-text').textContent = ending;

                // Mood strip
                const moodStrip = document.getElementById('mood-strip');
                moodStrip.style.background = MOOD_COLORS[this.currentMood];

                // Top matched words
                const topWords = Object.entries(this.matchedWordCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);

                const matchedWordsEl = document.getElementById('matched-words');
                if (topWords.length > 0) {
                    matchedWordsEl.innerHTML = topWords.map(([word, count]) =>
                        `<div class="word-chip">${word} (${count})</div>`
                    ).join('');
                } else {
                    matchedWordsEl.innerHTML = '<span style="opacity: 0.5; font-size: 0.875rem;">No mood keywords matched</span>';
                }

                // Stats
                document.getElementById('ending-stats').textContent =
                    `Total edits: ${this.totalAdded + this.totalRemoved} · Final word count: ${currentTokens.length}`;

                // Switch panel
                this.showPanel('ending-panel');
            },

            copyFinalText() {
                const text = document.getElementById('story').innerText;
                navigator.clipboard.writeText(text).then(() => {
                    this.showToast('Copied to clipboard!');
                });
            },

            downloadJSON() {
                const data = {
                    finalText: document.getElementById('story').innerText,
                    mood: this.currentMood,
                    addedCount: this.totalAdded,
                    removedCount: this.totalRemoved,
                    matchedWords: this.matchedWordCounts,
                    timestamp: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rewrite-me-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showToast('JSON downloaded!');
            },

            editAgain() {
                this.showPanel('editor-panel');
            },

            startExperience() {
                this.showPanel('editor-panel');
                setTimeout(() => {
                    document.getElementById('story').focus();
                }, 300);
            },

            showPanel(panelId) {
                document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
                document.getElementById(panelId).classList.add('active');
            },

            showToast(message, action = null) {
                const toast = document.getElementById('toast');
                toast.innerHTML = `
                    <span>${message}</span>
                    ${action ? `<button onclick="${action.handler}">${action.label}</button>` : ''}
                `;
                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            },

            startAutoSave() {
                this.autoSaveInterval = setInterval(() => {
                    const text = document.getElementById('story').innerText;
                    if (text !== ORIGINAL_STORY) {
                        localStorage.setItem('rewriteMe_autosave', JSON.stringify({
                            text,
                            totalAdded: this.totalAdded,
                            totalRemoved: this.totalRemoved,
                            editLog: this.editLog,
                            timestamp: Date.now()
                        }));
                    }
                }, 2000);
            },

            loadAutoSave() {
                const saved = localStorage.getItem('rewriteMe_autosave');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        const age = Date.now() - data.timestamp;

                        // Only restore if less than 1 hour old
                        if (age < 3600000) {
                            this.showToast('Restored your unsaved edit.', {
                                label: 'Discard',
                                handler: 'app.discardAutoSave()'
                            });

                            // Restore on next tick to allow toast to show
                            setTimeout(() => {
                                document.getElementById('story').textContent = data.text;
                                this.totalAdded = data.totalAdded;
                                this.totalRemoved = data.totalRemoved;
                                this.editLog = data.editLog;
                                this.previousTokens = this.tokenize(data.text);
                                this.updateMood();
                                this.renderEditLog();
                                this.updateStats();
                            }, 100);
                        } else {
                            localStorage.removeItem('rewriteMe_autosave');
                        }
                    } catch (e) {
                        localStorage.removeItem('rewriteMe_autosave');
                    }
                }
            },

            discardAutoSave() {
                localStorage.removeItem('rewriteMe_autosave');
                this.reset();
                document.getElementById('toast').classList.remove('show');
            }
        };

        // Initialize app when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => app.init());
        } else {
            app.init();
        }
    </script>
</body>
</html>
